# -*- coding: utf-8 -*-
"""linearRegression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1isYdBFvQW8Xg8jWeB-1N5g-aXzKKzQyv

LINEAR REGRESSION WITHOUT FRAMEWORKS: y = mx + b
"""

# Commented out IPython magic to ensure Python compatibility.
# Import libraries and create data frame
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from google.colab import drive

drive.mount("/content/gdrive")  
!pwd 
# %cd "/content/gdrive/MyDrive/IA4DS/AprendizajeDeMaquina/linearRegression"
!ls 

df = pd.read_csv('data.csv') 
df.head()

# Plot the data
plt.scatter(df.height, df.weight)
plt.show()

"""# Solution 1: Calculating m and b values using math"""

# Create x and y variables
x = df[['weight']]
y = df.height

"""Calculating the slope m of the regression line

1. Step calculating SSxx
"""

# Calculate SSxx 
xmean = x.mean()
df['diffx'] = xmean - x
df['diffx_squared'] = df.diffx**2
SSxx = df.diffx_squared.sum()

"""2. Step calculating SSxy"""

# Calculate SSxy
ymean = y.mean()
df['diffy'] = ymean - y
SSxy = (df.diffx * df.diffy).sum()

"""Slope"""

# Slope: calculate m value
m = SSxy / SSxx

"""Calculating the intercept b of the regression line """

# Calculate the intercept 'b' of the regression line
b = ymean - m*xmean

# Plot data and linear regression
import matplotlib.pyplot as plt
plt.scatter(x,y)
plt.plot(x, m*x+b, 'r' )

"""Predict values with the model"""

# Predict values
def predict(value):
  predict = m * value + b
  return predict

# Test for prediction of 67.99831
predict(67.99831)

"""Sklearn comparison

"""

# Compare result of the model with the result of sklearn
from sklearn import linear_model
model = linear_model.LinearRegression()
model.fit(x,y)

# Get sklearn linear regression value
model.coef_
model.intercept_
model.predict([[140]])

"""## Solution 2: implementing a Linear Regression Class


"""

class LinearRegression():      
    def __init__(self, learning_rate, iterations):
        self.learning_rate = learning_rate
        self.iterations = iterations
          
    # Training function
    def fit(self, X, Y):
        # m = training_examples, n = features
        self.m, self.n = X.shape
        # Declare Weight 
        self.W = np.zeros(self.n)
        self.b = 0
        self.X = X
        self.Y = Y
        # Gradient descent learning
        for i in range(self.iterations):
            self.update_weights()
        return self
      
    # Function for updating weights
    def update_weights(self):
        Y_pred = self.predict(self.X)
        # Get gradients  
        dW = - (2 * (self.X.T).dot(self.Y - Y_pred)) / self.m
        db = - 2 * np.sum(self.Y - Y_pred) / self.m 
        # Update weights
        self.W = self.W - self.learning_rate * dW
        self.b = self.b - self.learning_rate * db
        return self
      
    # Predict function
    def predict(self, X):
        return X.dot(self.W) + self.b

# Assign x and y values; scaling data 
X = df.iloc[:,:-1].values
X = preprocessing.scale(X)
Y = df.iloc[:,1].values
Y = preprocessing.scale(Y)
  
# Create train and test set
x_train, x_test, y_train, y_test = train_test_split(X, Y)
  
# Training using the class model
lrModel = LinearRegression(learning_rate = 0.01, iterations = 100)
lrModel.fit(x_train, y_train)
  
# Make predictions
predictions = lrModel.predict(x_test)
print("Predicted values ", np.round(predictions[:3], 3)) 
print("Real values ", np.round(y_test[:3],3))
  
# Visualization of test values and predictions 
plt.scatter(x_test, y_test, color = 'green')
plt.plot(x_test, predictions, color = 'red')
plt.title('Height and Weight')
plt.xlabel('Weight')
plt.ylabel('Height')
plt.show()